WITH params AS (
  SELECT
    interval '3 months' AS monthly_min_future,
    interval '7 days'   AS daily_min_future,
    interval '14 days'  AS weekly_min_future
),
range_parents AS (
  SELECT
    p.partrelid AS parent_oid,
    format('%I.%I', pn.nspname, pc.relname) AS parent_fqname,
    pg_get_partkeydef(p.partrelid)          AS partition_key_def
  FROM pg_partitioned_table p
  JOIN pg_class pc      ON pc.oid = p.partrelid
  JOIN pg_namespace pn  ON pn.oid = pc.relnamespace
  WHERE p.partstrat = 'r'
    AND pn.nspname NOT IN ('pg_catalog', 'information_schema')
),
child_bounds AS (
  SELECT
    rp.parent_oid,
    rp.parent_fqname,
    rp.partition_key_def,
    pg_get_expr(ch.relpartbound, ch.oid) AS bound_expr
  FROM range_parents rp
  JOIN pg_inherits i ON i.inhparent = rp.parent_oid
  JOIN pg_class ch   ON ch.oid = i.inhrelid
),
child_tos AS (
  SELECT
    parent_fqname,
    partition_key_def,
    (bound_expr = 'DEFAULT') AS is_default,
    CASE
      WHEN bound_expr = 'DEFAULT' THEN NULL
      ELSE (regexp_match(bound_expr, $$TO\s*\(\s*'([^']+)'$$))[1]::timestamptz
    END AS to_ts
  FROM child_bounds
),
ranked AS (
  -- Rank partitions by TO bound (latest first). Ignore DEFAULT for ranking.
  SELECT
    ct.*,
    row_number() OVER (
      PARTITION BY parent_fqname
      ORDER BY to_ts DESC NULLS LAST
    ) AS rn
  FROM child_tos ct
  WHERE ct.is_default = false
    AND ct.to_ts IS NOT NULL
),
rollup AS (
  SELECT
    p.parent_fqname,
    p.partition_key_def,
    -- DEFAULT may exist even if we filtered it out of ranked; compute from child_tos
    (SELECT bool_or(is_default) FROM child_tos ct2 WHERE ct2.parent_fqname = p.parent_fqname) AS has_default_partition,
    max(to_ts) FILTER (WHERE rn = 1) AS latest_to_ts,
    max(to_ts) FILTER (WHERE rn = 2) AS prev_to_ts
  FROM (
    SELECT DISTINCT parent_fqname, partition_key_def
    FROM child_tos
  ) p
  LEFT JOIN ranked r
    ON r.parent_fqname = p.parent_fqname
  GROUP BY p.parent_fqname, p.partition_key_def
),
final AS (
  SELECT
    r.*,
    (r.latest_to_ts - r.prev_to_ts) AS partition_span,
    CASE
      WHEN r.prev_to_ts IS NULL OR r.latest_to_ts IS NULL THEN 'unknown'
      WHEN (r.latest_to_ts - r.prev_to_ts) BETWEEN interval '18 hours' AND interval '30 hours' THEN 'daily'
      WHEN (r.latest_to_ts - r.prev_to_ts) BETWEEN interval '5 days'   AND interval '9 days'  THEN 'weekly'
      WHEN (r.latest_to_ts - r.prev_to_ts) BETWEEN interval '20 days'  AND interval '40 days' THEN 'monthly'
      ELSE 'other'
    END AS cadence
  FROM rollup r
)
SELECT
  f.parent_fqname,
  f.partition_key_def,
  f.has_default_partition,
  f.latest_to_ts,
  f.partition_span,
  f.cadence,
  CASE f.cadence
    WHEN 'daily'   THEN now() + (SELECT daily_min_future   FROM params)
    WHEN 'weekly'  THEN now() + (SELECT weekly_min_future  FROM params)
    WHEN 'monthly' THEN now() + (SELECT monthly_min_future FROM params)
    ELSE NULL
  END AS required_future_until,
  CASE f.cadence
    WHEN 'daily'   THEN (f.latest_to_ts >= now() + (SELECT daily_min_future   FROM params))
    WHEN 'weekly'  THEN (f.latest_to_ts >= now() + (SELECT weekly_min_future  FROM params))
    WHEN 'monthly' THEN (f.latest_to_ts >= now() + (SELECT monthly_min_future FROM params))
    ELSE NULL
  END AS has_required_future_partitions
FROM final f
ORDER BY f.parent_fqname;
